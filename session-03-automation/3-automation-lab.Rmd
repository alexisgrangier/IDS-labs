---
title: "Iteration, Automation, Scheduling"
subtitle: ""
author: "Killian Conyngham and Carol Sobral"
date: "(Fall 2025) Introduction to Data Science"
output: 
    rmdformats::robobook:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: tango
    toc_depth: 3
    toc_float: true
    self_contained: false
---

```{=html}
<style>
.h1,h2,h3 {
color:#2f1a61;
}

.subtitle, section.normal {
color:#291854;
}

.title {
color:#cc0065;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Welcome to Week 3! `r emo::ji("wave")`


This week's tutorial will be divided in three parts. 


---


# 4. Debugging `r emo::ji("beetle")` (to read at home `r emo::ji("house")`)

When you write code, things will inevitably go wrong at some point. You can professionalize the way you:

-   fix unanticipated problems (debugging)
-   let functions communicate problems and take actions based on those communications (condition handling)
-   learn how to avoid common problems before they occur (defensive programming)

Potential problems are communicated via "conditions" (e.g., errors, warnings, and messages). For example

-   fatal errors are raised by `stop()` and force all execution to terminate
-   warnings are generated by `warning()` and display potential problems
-   messages are generated by `message()` and can provide informative output on the way

------------------------------------------------------------------------

## Debugging workflow

1.  Realize that you have a bug
2.  Make the bug repeatable: start with big chunk of code and narrow it down to isolate it
3.  Figure out where it is
4.  Fix it and test it

------------------------------------------------------------------------

## Debugging tools `r emo::ji("flashlight")`

The following function that calculates the geodesic distance between two points specified by radian latitude/longitude using the Haversine formula (hf); taken from [here](https://goo.gl/GezNGB), as an example. We've inserted some bugs here... `r emo::ji("bug")`

```{r eval = FALSE}
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  
  # from degrees to radians
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(long2)
  lat2 <- deg2rad(lat2)
  
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}

geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
```

------------------------------------------------------------------------

### Trial and error `r emo::ji("graduation_cap")`

That is, if you see the error right away, try and fix it. You have lots of experience doing that. `r emo::ji("nerd_face")`

------------------------------------------------------------------------

### Making function global `r emo::ji("globe")`

One way to approach debugging is to turn the arguments of the function into global objects (objects you can see in your environment, otherwise the objects are only available within your function). Then you can step through the code line by line to locate the bug.

```{r}
# make the objects that are otherwise entered as input parameters to your function global
lat1 <- 49.5; lon1 <-  8.4; lat2 <-  52.5; lon2 <- 13.4
```

```{r eval = FALSE}
# now, execute line by line
deg2rad <- function(deg) return(deg*pi/180)
lon1 <- deg2rad(lon1)
lat1 <- deg2rad(lat1)
lon2 <- deg2rad(long2)
lat2 <- deg2rad(lat2)
delta.long <- (lon2 - lon1)
delta.lat <- (lat2 - lat1)
a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
c <- 2 * asin(min(1,sqrt(a)))
d = earth_radius * c
return(d)
```

**Problem:** This creates global objects that match arguments names, which can become confusing and cause problems that become obvious when the function is called in a different environment. `r emo::ji("warning")`

> In case you choose this option, it is a good idea to clean your environment afterwards, or simply to remove all the new global objects using `rm()`.

**Side note** If you haven't done so already, as a general best practice advise, change the settings in your global options to "never" save the workspace as this can cause similar issues to the example described above.

```{r,  echo=F}
knitr::include_graphics("pics/workspace.png", dpi = 100)
```

------------------------------------------------------------------------

### Using `traceback()` `r emo::ji("point_left")`

```{r eval = FALSE}
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
traceback()
```

This shows you where the error occurred (but not why). Read from bottom to top (e.g. 1. called function X, 2. called function Y, error occurred in line #6 of function Y)

------------------------------------------------------------------------

### Using `browser()` `r emo::ji("fox")`

You can add `browser()` into your function somewhere before you expect the error.

**Note:** While `browser()` works best within a clean .R script, it can also help with troubleshooting within .Rmd files.

```{r eval = FALSE}
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  # from degrees to radians
  browser()
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(lon2)
  lat2 <- deg2rad(lat2)
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
```

You can then interactively work through the function line by line by hitting enter in the console or send additional lines of code.

```{r, echo=F}
knitr::include_graphics("pics/browser.png", dpi = 100)
```

**Note:** Other helpful tools for debugging R functions written by someone else include `debug()` which automatically opens a debugger at the start of a function call and `trace()` which allows temporary code modifications inside functions that you can't easily access to (e.g. `ggplot()`).

------------------------------------------------------------------------

## Condition handling ``` r emo::ji("ant")``r emo::ji("ant")``r emo::ji("bee")``r emo::ji("ant") ```

Sometimes errors come expected, and you want to handle them automatically, e.g.:

-   model fails to converge
-   file download fails
-   stack processing of lists

Useful functions to deal with such cases: `try()` and `tryCatch()`

```{r eval = FALSE}
f1 <- function(x) { 
  log(x) 
  10 
} 

f1("x")
```

------------------------------------------------------------------------

### Using `try()` `r emo::ji("person_shrugging")`

Ignore error:

```{r}
f1 <- function(x) { 
  try(log(x))
  10 
} 

f1("x")
```

Suppress error message:

```{r}
f1 <- function(x) { 
  try(log(x), silent = TRUE)
  10 
} 
f1("x")
```

Pass block of code to `try()`:

```{r}
try({ 
  a <- 1 
  b <- "x" 
  a + b 
})
```

Capture the output of `try()`:

```{r}
success <- try(1 + 2) 
failure <- try("a" + "b") 
class(success)
class(failure) 
```

Use `possibly()`, a function similar to `try()` from the purrr package when applying a function to multiple elements in a list. You can also provide a default value (here: `NA`) in case execution fails.

```{r eval = FALSE}
library(purrr)

elements <-list(1,2,3,"f")

results_a <- purrr::map(elements, log)
results_b <- purrr::map(elements, purrr::possibly(log, NA))
```

------------------------------------------------------------------------

### Condition handling with `tryCatch()` `r emo::ji("fishing_pole")`

React to conditions, such as errors, warnings, messages, or interruptions, with certain actions "handlers". These are functions that map conditions to condition handler functions that can do anything but typically will return a value or create a more informative error message:

```{r}
show_condition <- function(code) { 
  tryCatch(code, 
           error = function(c) "error", 
           warning = function(c) "warning", 
           message = function(c) "message" )
}

show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))
```

If no condition is captured, `tryCatch()` returns the value of the input:

```{r}
show_condition(10+5)
```

A more real-life example of how to use `tryCatch()` is this one:

```{r}
model_selection <- function(data, formula1, formula2){
  
  tryCatch(lm(formula1, data), error = function(e) lm(formula2, data))
  
}
```

You try to fit `formula1` to the data, however, maybe it is a model with very strict requirements. You might also have a more robust (but maybe less interesting) `formula2` that you might fit if the requirements are not met and the modeling process throws an error.

Make more informative error messages:

```{r eval = FALSE}
read.csv_new <- function(file, ...) { 
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in file: ", file, ")") 
    stop(c) 
  })
}

read.csv("code/dummy.csv")
read.csv_new("code/dummy.csv")
```

------------------------------------------------------------------------

## Defensive programming `r emo::ji("shield")`

-   "making code fail in a well-defined manner"

-   "fail fast": as soon as something wrong is discovered, signal an error

-   Three rules to implement the "fail fast" principle:

1.  be strict about what you accept (e.g., only scalars)
2.  avoid functions that use non-standard evaluation, such as `subset()`, `transform()`, or `with()`
3.  avoid functions that return different types of output depending on their input (e.g. `sapply`)

------------------------------------------------------------------------


## Debugging Exercise `r emo::ji("skull")`

Here is a piece of code that comes with a few flaws. As an optional take-home exercise, please identify the bugs, remove them and report what you have done using comments.

```{r, eval = FALSE}
# load packages
library(tidyverse)
library(LegislatoR) 

# get political data on German legislators
political_df <- 
  left_join(x = filter(get_political(legislature = "ger"), as.numeric("session") == 18), 
            y = get_core(legislature = "ger"), by = "pageid") 

# wiki traffic data
traffic_df <- 
  get_traffic(legislature = "ger") |> 
  filter(date >= "2013-10-22" & date <= "2017-10-24") |> 
  group_by(pageid) |> 
  summarize(traffic_mean = mean(traffic, na.rm = TRUE),
            traffic_max = max(traffic, na.rm = TRUE))

# sessions served
sessions_served_df <- 
  get_political(legislature = "deu") %% 
  group_by(pageid) |> 
  dplyr::summarize(sessions_served = n())

# merge
legislator_df <- 
  left_join(political_df, sessions_served_df, by = "pageid") |> 
  left_join(traffic_df, by = "pageid") 

# compute age
get_age <- function(birth, date_at) {
  date_at_fmt <- date_at
  birth_fmt <- birth
  diff <- difftime(lubridate::ymd(birth_fmt), lubridate::ymd(date_at_fmt))
  diff_years <- time_length(diff, "years") 
  diff_years
}
legislator_df$age_in_years <- round(get_age(legislator_df$birth, "2017-10-24"), 0)

# plot top 10 pageviews
legislator_df <- arrange(legislator_df, desc(traffic_mean))
legislator_df$rank <- 1:nrow(legislator_df)
legislator_df_table <- dplyr::select(rank, name, traffic_mean, traffic_max) 
names(legislator_df_table) <- c("Rank", "Representative", "Mean", "Maximum") 
legislator_df_table <- head(legislator_df_table, 10)

ggplot(legislator_df_table, aes(y = Mean, x = -Rank)) + 
  xlab("Rank") + ylab("Avg. daily page views") + 
  labs(title = "Top 10 representatives by average daily page views") + 
  geom_bar(stats = "identity") + # change to geom_col
  scale_x_continuous(breaks = -nrow(legislator_df_table):-1, labels = rev(1:nrow(legislator_df_table))) # add +
geom_text(aes(y = 10, label = Representative), hjust = 0, color = "white", size = 2) + 
  coord_flip() + 
  theme_minimal()

# run model of page views as a function of sessions served, party, sex, and age in years
legislator_df$traffic_log <- log(legislator_df$traffic_mean)

covars <- c("sessions_served", "party", "sex", "age_in_years")
fmla <- paste("traffic_log", paste(covars, collapse = " - "), sep = " ~ ") 
summary(log_traffic_model <- lm(fmla, legislator_df))

# plot table
sjPlot::tab_model(log_traffic_model)
```




# <b style="color:#2f1a61">Acknowledgements</b> {-}

This script was drafted by [Tom Arendt](https://github.com/tom-arend) and [Lisa Oswald](https://lfoswald.github.io/), with contributions by [Steve Kerr](https://smkerr.github.io/), [Hiba Ahmad](https://github.com/hiba-ahmad), [Carmen Garro](https://github.com/cgarroca), [Sebastian Ramirez-Ruiz](https://seramirezruiz.github.io/), [Killian Conyngham](https://github.com/Killian-Conyngham) and [Carol Sobral](https://github.com/cbsobral). It draws heavily on the materials for the Introduction to R workshop within the Data Science Seminar series at Hertie, created by [Therese Anders](http://therese.rbind.io/), Statistical Modeling and Causal Inference by Sebastian Ramirez-Ruiz and Lisa Oswald.

Economist Intelligence Unit (2017): *Democracy Index*. https://infographics.economist.com/2017/DemocracyIndex/.

Imai, Kosuke (2017): *Quantitative Social Science. An Introduction*. Princeton and Oxford: Princeton University Press.

Raleigh, Clionadh, Andrew Linke, Håvard Hegre and Joakim Karlsen. 2010. Introducing ACLED – Armed Conflict Location and Event Data. *Journal of Peace Research* 47(5), 651-660.

World Bank (2017): *Population, total*. https://data.worldbank.org/indicator/sp.pop.totl?end=2016&start=2015.

